<!DOCTYPE html>
<html lang="en">
    <head>
        <script src="https://d3js.org/d3.v4.min.js"></script>
    </head>
    <body>
        <svg width="960" height="960" font-family="sans-serif" font-size="10" text-anchor="middle"></svg>
        <script>


          var svg = d3.select("svg"),
              width = +svg.attr("width"),
              height = +svg.attr("height");

          var format = d3.format(",d");

          var color = d3.scaleOrdinal(d3.schemeCategory20c);

          var pack = d3.pack()
              .size([width, height])
              .padding(1.5);

          d3.csv("BubbleChartData.txt", function(d) {
            d.value = +d.value;
            if (d.value) return d;
          }, function(error, classes) {
            if (error) throw error;

            var root = d3.hierarchy({children: classes})
                .sum(function(d) { return d.value; })
                .each(function(d) {
                  if (id = d.data.id) {
                    var id, i = id.lastIndexOf(".");
                    d.id = id;
                    d.package = id.slice(0, i);
                    d.class = id.slice(i + 1);
                  }
                });

            var node = svg.selectAll(".node")
              .data(pack(root).leaves())
              .enter().append("g")
                .attr("class", "node")
                .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
                .call(d3.drag());

            node.append("circle")
                .attr("id", function(d) { return d.id; })
                .attr("r", function(d) { return d.r; })
                .style("fill", function(d) { return color(d.package); });

            /*node.append("clipPath")
                .attr("id", function(d) { return "clip-" + d.id; })
              .append("use")
                .attr("xlink:href", function(d) { return "#" + d.id; });*/

            node.append("text")
               .attr("dy", ".3em")
               .style("text-anchor", "middle")
               .text(function(d) { return d.id; });

            /*node.append("text")
                /*.attr("clip-path", function(d) { return "url(#clip-" + d.id + ")"; })
              .selectAll("tspan")
              .data(function(d) { return d.id; })
              /*.enter().append("tspan")
                .attr("x", 0)
                .attr("y", function(d, i, nodes) { return 13 + (i - nodes.length / 2 - 0.5) * 10; })
                .text(function(d) { return d; });*/

            node.append("title")
                .text(function(d) { return d.id + "\n" + format(d.value); });

            var force = d3.forceSimulation(node)
                  .velocityDecay(0.2)
                  .force("x", d3.forceX().strength(.0005))
                  .force("y", d3.forceY().strength(.0005))
                  //.gravity(0)
                  //.charge(0)
                  //.size([width, height])
                  .on("tick", tick);

                  function tick() {
                      console.log('tick');
                      node
                          .attr('cx', (d) => d.x)
                          .attr('cy', (d) => d.y);
                  }

                  function collide(alpha) {
                    console.log(collide);
                    var quadtree = d3.quadtree()
                        .x((d) => d.x)
                        .y((d) => d.y)
                        .addAll(nodes);

                    node.forEach(function(d) {
                      var r = d.r + maxRadius + Math.max(padding, clusterPadding),
                          nx1 = d.x - r,
                          nx2 = d.x + r,
                          ny1 = d.y - r,
                          ny2 = d.y + r;
                      quadtree.visit(function(quad, x1, y1, x2, y2) {

                        if (quad.data && (quad.data !== d)) {
                          var x = d.x - quad.data.x,
                              y = d.y - quad.data.y,
                              l = Math.sqrt(x * x + y * y),
                              r = d.r + quad.data.r + (d.cluster === quad.data.cluster ? padding : clusterPadding);
                          if (l < r) {
                            l = (l - r) / l * alpha;
                            d.x -= x *= l;
                            d.y -= y *= l;
                            quad.data.x += x;
                            quad.data.y += y;
                          }
                        }
                        return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
                      });
                    });
                  }



          });


        </script>
    </body>
</html>
